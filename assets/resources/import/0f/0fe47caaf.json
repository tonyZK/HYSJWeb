[1,["baGAs9Uj9LzrF/Rh+MWLY/","fdoJXLgx1GAa2UhGATlj3o","2cL3NVsrBAuawPuCTY92v0@f9941","acdnqHM5dIW6wcet4kiIw/@f9941","45sIbdP5pDiZ1wji6x9lZ9@f9941","70Jt0tYc1NzKULn+n8KFpL@f9941","5cYMfN6c1D4py4QBMSB1k1","2cL3NVsrBAuawPuCTY92v0@6c48a","34Fh1ithBJ+6+kYkRljm3F@6c48a","45sIbdP5pDiZ1wji6x9lZ9@6c48a","34Fh1ithBJ+6+kYkRljm3F@f9941","70Jt0tYc1NzKULn+n8KFpL@6c48a","acdnqHM5dIW6wcet4kiIw/@6c48a","ed7ZzSATFDeYouO2Q8/bsh"],["node","_customMaterial","_textureSource","_spriteFrame","effectTemplate","root","redPControllerItem","usingNode","drag","levelUpNode","skillLevelLabel","skillShader","skillIconSp","data","_parent","_font","spriteFrame","_effectAsset"],["cc.SpriteFrame",["cc.Node",["_name","_layer","_components","_prefab","_parent","_children","_lpos","_lscale"],1,9,4,1,2,5,5],["cc.Widget",["_alignFlags","_originalWidth","_originalHeight","_bottom","_right","_top","_left","node","__prefab"],-4,1,4],["cc.Node",["_name","_layer","_components","_prefab","_parent","_lscale","_lpos"],1,12,4,1,5,5],["cc.Sprite",["_fillType","_sizeMode","_fillRange","node","__prefab","_customMaterial","_spriteFrame","_fillCenter"],0,1,4,6,6,5],["cc.Prefab",["_name"],2],["19191jSfgVF1KV46UTUZS8W",["node","__prefab","skillIconSp","skillShader","skillLevelLabel","levelUpNode","drag","usingNode","redPControllerItem"],3,1,4,1,1,1,1,1,1,1],["cc.CompPrefabInfo",["fileId"],2],["cc.Button",["node","__prefab","_hoverColor","_pressedColor"],3,1,4,5,5],["89d62J0iiNIdq4/OrF8hcBR",["node","__prefab","highLightNodes"],3,1,4,2],["cc.UIOpacity",["node","__prefab"],3,1,4],["cc.UITransform",["node","__prefab","_contentSize"],3,1,4,5],["cc.PrefabInfo",["fileId","instance","targetOverrides","nestedPrefabInstanceRoots","root","asset"],-1,1,1],["c46b2NGbRdPOqilXzfJzWSX",["_useNodeSize","node","__prefab","effectTemplate"],2,1,4,6],["11ee9ZzPQhFLYcnUaK+4dW5",["_curAngle","node","__prefab"],2,1,4],["8f630H+1WZJRqNn4/N8oqlI",["node","__prefab","_pureColor"],3,1,4,5],["990b8PrShFLqbKc4V8+KBoj",["_enabled","node","__prefab"],2,1,4],["5c939aPuVJOmr9syrpx6hSP",["node","__prefab"],3,1,4],["cc.Label",["_string","_actualFontSize","_fontSize","_lineHeight","_isSystemFontUsed","_underlineHeight","node","__prefab"],-3,1,4],["90e97hH+0xJCqXMWVw9C1M/",["node","__prefab"],3,1,4],["cc.BitmapFont",["_name","fontSize","fntConfig"],0],["cc.Material",["_name","_props","_states","_defines"],-1],["cc.EffectAsset",["_name","combinations","shaders","techniques"],-1]],[[7,0,2],[10,0,1,1],[11,0,1,2,1],[12,0,1,2,3,4,5,5],[4,3,4,5,6,1],[13,0,1,2,3,2],[1,0,1,4,5,2,3,3],[1,0,1,4,2,3,3],[2,0,1,2,7,8,4],[15,0,1,2,1],[5,0,2],[1,0,1,5,2,3,6,3],[1,0,1,4,5,2,3,6,7,3],[1,0,1,4,2,3,6,7,3],[3,0,1,2,3,3],[3,0,1,4,2,3,5,3],[3,0,1,4,2,3,6,3],[6,0,1,2,3,4,5,6,7,8,1],[8,0,1,2,3,1],[9,0,1,2,1],[2,0,3,7,8,3],[2,0,7,8,2],[2,0,6,4,5,3,1,2,7,8,8],[2,0,4,5,7,8,4],[4,0,1,2,3,4,7,5,6,4],[4,3,4,1],[14,0,1,2,2],[16,0,1,2,2],[17,0,1,1],[18,0,1,2,3,4,5,6,7,7],[19,0,1,1],[20,0,1,2,4],[21,0,1,2,3,5],[22,0,1,2,3,5]],[[[[10,"SkillGridViewCell"],[11,"SkillGridViewCell",33554432,[-15,-16,-17],[[17,-9,[0,"dcE2X23JpPuo+LiYBsb8UW"],-8,-7,-6,-5,-4,-3,-2],[18,-10,[0,"5aaB6/agpEFYeFuPQ0CTfP"],[4,4294967295],[4,4292072403]],[19,-12,[0,"8am3NZHWZMVrAx13YT2vLB"],[-11]],[1,-13,[0,"caoJ25jMpN9YXpFFHlNIk9"]],[2,-14,[0,"0fBfF+9m5Nl5KOjbL+3m9v"],[5,80,80]]],[3,"2eMzD7yTtAbKrJut9yWmQw",null,null,null,-1,0],[1,683,0,0]],[6,"iconNode",33554432,1,[-21,-22,-23,-24],[[8,45,120,120,-18,[0,"a0OuaXx1pGaIlqDjTP0U7U"]],[1,-19,[0,"d4rDC5U81Hn5+vOd5mDhFr"]],[2,-20,[0,"336Dtd4vBKX7fafZK86P9c"],[5,80,80]]],[3,"3f1aSvUhhOlKUbNHQ1I9TG",null,null,null,1,0]],[7,"highLight",33554432,2,[[24,2,0,0.2,-25,[0,"b4KeFNKOtC7atb+kCylGrI"],[0,0.5,0.5],4,5],[5,true,-26,[0,"5c0obiBQhEsZ/6dGvmFOEu"],6],[26,263.64266666674905,-27,[0,"7axvLdENFM7LYQGn8BAeTJ"]],[1,-28,[0,"cbYJi2t55B9YE/4lTQrM9n"]],[2,-29,[0,"4bjpbC9IBGSZI3W3LshDHC"],[5,78,78]],[9,-30,[0,"8bh2T22hNF1o/PmsTVvKfa"],[4,4280654567]]],[3,"dczaWv/rdM0bOjppvbk6+b",null,null,null,1,0]],[14,"icon",33554432,[[-31,[5,true,-32,[0,"afWwRoKwRJ8avicYtUVsQP"],0],-33,-34,[1,-35,[0,"4cVBvHoCBFrZACxqTRvch/"]],[2,-36,[0,"5fuTwj8/pNgKgChaamBUOa"],[5,45,45]]],1,4,1,1,4,4],[3,"177oQK3bNDDp+EqLR4wx0q",null,null,null,1,0]],[7,"frame",33554432,2,[[4,-37,[0,"77LQZ72ktHIqVRX/tFIXaQ"],1,2],[8,45,120,120,-38,[0,"c3HA1BImdGI4oHJfHaRTmr"]],[1,-39,[0,"45KxFZcHNI1aQD/wrSVIkY"]],[2,-40,[0,"4f+TMhadBBnaJbufbN4/P3"],[5,80,80]],[5,true,-41,[0,"93GeBMeQ1IlLzROzjYNISn"],3],[9,-42,[0,"38zCYZg35BtL9/sCx8HCqn"],[4,4286940550]]],[3,"26N0pBYXVJ5JcF//Bc1g+S",null,null,null,1,0]],[12,"lv",33554432,2,[-47],[[4,-43,[0,"bcuHaLGmZO3LRBdmDPmFAW"],7,8],[20,4,-3.6940000000000026,-44,[0,"46iQbBPXpLcJlLfS/IeHa6"]],[1,-45,[0,"88SXfqMCxEwZbgFWsP+iay"]],[2,-46,[0,"04ZVAxVMxJs6pe4YqamOna"],[5,210,38]]],[3,"edd7VqjVZPXKGNabxqoVFG",null,null,null,1,0],[1,0,-37.994,0],[1,0.3,0.3,1]],[13,"inusing",33554432,1,[[4,-48,[0,"a1w9jrEX9F65g4oVvEDf7f"],9,10],[21,9,-49,[0,"61/VVPn/BKOpt5/jgcbORy"]],[1,-50,[0,"b2ZT4XxwVNqoiDa4uvTAYi"]],[2,-51,[0,"4b3lc6qvVNL6YPQjfxjgrr"],[5,81,51]]],[3,"1aey3bE5dHUa+8CirCX7pI",null,null,null,1,0],[1,-15.7,24.700000000000003,0],[1,0.6,0.6,0.6]],[15,"lv",33554432,6,[[-52,[22,18,66.62,-87.71,41.1,69.66333,48.94,37.8,-53,[0,"88U1j9tMVCKYrnYMhTAFnE"]],[1,-54,[0,"68j3WX4GNDGIQUB6NyRmDK"]],[2,-55,[0,"18zTDumodFAqLu0zcNljAs"],[5,11.25,24]]],1,4,4,4],[3,"cbrqldLK9C3rs+jSydolM4",null,null,null,1,0],[1,2,2,0.6]],[16,"redPoint",33554432,1,[[[23,33,10,10,-56,[0,"82RU0HT0dOu5mOh8+BeubD"]],-57,[1,-58,[0,"1fiFyHa69Keo2uxslEr4U5"]],[2,-59,[0,"6c9QXM3SNCQpQWkxoJ4Exy"],[5,0,0]]],4,1,4,4],[3,"edyTqa7EFJZ5qMHSADHCOK",null,null,null,1,0],[1,30,30,0]],[6,"img",33554432,2,[4],[[1,-60,[0,"51A7400yRNUoXKeKhvfcHy"]],[2,-61,[0,"d1xItQqW9KFKdWNMgmuj5n"],[5,0,0]]],[3,"ebyDl/v/tLuKP5KRIxAwXN",null,null,null,1,0]],[25,4,[0,"19nRuvXflOur/J9WHb1KKz"]],[27,false,4,[0,"15k9IQt2hBQ6Pq2+ZkFefk"]],[28,4,[0,"74KL6RV1lE75qv9371Z0BV"]],[29,"1",20,20,24,false,0,8,[0,"63Ub7rf6ZJ2LLMAGfnb4q2"]],[30,9,[0,"48zMFbCptH5IyGfNSW5qdI"]]],0,[0,5,1,0,6,15,0,7,7,0,8,13,0,9,6,0,10,14,0,11,12,0,12,11,0,0,1,0,0,1,0,-1,3,0,0,1,0,0,1,0,0,1,0,-1,2,0,-2,7,0,-3,9,0,0,2,0,0,2,0,0,2,0,-1,10,0,-2,5,0,-3,3,0,-4,6,0,0,3,0,0,3,0,0,3,0,0,3,0,0,3,0,0,3,0,-1,11,0,0,4,0,-3,12,0,-4,13,0,0,4,0,0,4,0,0,5,0,0,5,0,0,5,0,0,5,0,0,5,0,0,5,0,0,6,0,0,6,0,0,6,0,0,6,0,-1,8,0,0,7,0,0,7,0,0,7,0,0,7,0,-1,14,0,0,8,0,0,8,0,0,8,0,0,9,0,-2,15,0,0,9,0,0,9,0,0,10,0,0,10,0,13,1,4,14,10,61],[0,0,0,0,0,0,0,0,0,0,0,11,14,14],[4,1,3,4,1,3,4,1,3,1,3,1,1,15],[0,0,2,0,0,3,0,1,4,1,5,0,1,6]],[[{"name":"skillFrame","rect":{"x":0,"y":0,"width":80,"height":80},"offset":{"x":0,"y":0},"originalSize":{"width":80,"height":80},"rotated":false,"capInsets":[6,9,7,6],"vertices":{"rawPosition":[-40,-40,0,40,-40,0,-40,40,0,40,40,0],"indexes":[0,1,2,2,1,3],"uv":[0,80,80,80,0,0,80,0],"nuv":[0,0,1,0,0,1,1,1],"minPos":{"x":-40,"y":-40,"z":0},"maxPos":{"x":40,"y":40,"z":0}},"packable":true,"pixelsToUnit":100,"pivot":{"x":0.5,"y":0.5},"meshType":0}],[0],0,[0],[2],[7]],[[{"name":"roundNum1","rect":{"x":0,"y":0,"width":356,"height":48},"offset":{"x":-78,"y":8},"originalSize":{"width":512,"height":64},"rotated":false,"capInsets":[0,0,0,0],"vertices":{"rawPosition":[-178,-24,0,178,-24,0,-178,24,0,178,24,0],"indexes":[0,1,2,2,1,3],"uv":[0,64,356,64,0,16,356,16],"nuv":[0,0.25,0.6953125,0.25,0,1,0.6953125,1],"minPos":{"x":-178,"y":-24,"z":0},"maxPos":{"x":178,"y":24,"z":0}},"packable":true,"pixelsToUnit":100,"pivot":{"x":0.5,"y":0.5},"meshType":0}],[0],0,[0],[2],[8]],[[{"name":"titleBk","rect":{"x":0,"y":0,"width":210,"height":38},"offset":{"x":0,"y":0},"originalSize":{"width":210,"height":38},"rotated":false,"capInsets":[47,0,50,0],"vertices":{"rawPosition":[-105,-19,0,105,-19,0,-105,19,0,105,19,0],"indexes":[0,1,2,2,1,3],"uv":[0,38,210,38,0,0,210,0],"nuv":[0,0,1,0,0,1,1,1],"minPos":{"x":-105,"y":-19,"z":0},"maxPos":{"x":105,"y":19,"z":0}},"packable":true,"pixelsToUnit":100,"pivot":{"x":0.5,"y":0.5},"meshType":0}],[0],0,[0],[2],[9]],[[[31,"roundNum1",48,{"commonHeight":48,"fontSize":48,"atlasName":"roundNum1.png","fontDefDictionary":{"48":{"xOffset":0,"yOffset":0,"xAdvance":33,"rect":{"x":0,"y":0,"width":33,"height":45}},"49":{"xOffset":0,"yOffset":0,"xAdvance":27,"rect":{"x":35,"y":0,"width":27,"height":46}},"50":{"xOffset":0,"yOffset":0,"xAdvance":35,"rect":{"x":64,"y":0,"width":35,"height":45}},"51":{"xOffset":0,"yOffset":0,"xAdvance":33,"rect":{"x":101,"y":0,"width":33,"height":45}},"52":{"xOffset":0,"yOffset":0,"xAdvance":35,"rect":{"x":136,"y":0,"width":35,"height":45}},"53":{"xOffset":0,"yOffset":0,"xAdvance":35,"rect":{"x":173,"y":0,"width":35,"height":47}},"54":{"xOffset":0,"yOffset":0,"xAdvance":33,"rect":{"x":210,"y":0,"width":33,"height":47}},"55":{"xOffset":0,"yOffset":0,"xAdvance":37,"rect":{"x":245,"y":0,"width":37,"height":47}},"56":{"xOffset":0,"yOffset":0,"xAdvance":33,"rect":{"x":284,"y":0,"width":33,"height":48}},"57":{"xOffset":0,"yOffset":0,"xAdvance":37,"rect":{"x":319,"y":0,"width":37,"height":47}}},"kerningDict":{}}]],0,0,[0],[16],[10]],[[{"name":"4","rect":{"x":1,"y":1,"width":81,"height":51},"offset":{"x":-2,"y":2},"originalSize":{"width":87,"height":57},"rotated":false,"capInsets":[0,0,0,0],"vertices":{"rawPosition":[-40.5,-25.5,0,40.5,-25.5,0,-40.5,25.5,0,40.5,25.5,0],"indexes":[0,1,2,2,1,3],"uv":[1,56,82,56,1,5,82,5],"nuv":[0.011494252873563218,0.08771929824561403,0.9425287356321839,0.08771929824561403,0.011494252873563218,0.9824561403508771,0.9425287356321839,0.9824561403508771],"minPos":{"x":-40.5,"y":-25.5,"z":0},"maxPos":{"x":40.5,"y":25.5,"z":0}},"packable":true,"pixelsToUnit":100,"pivot":{"x":0.5,"y":0.5},"meshType":0}],[0],0,[0],[2],[11]],[[{"name":"itemFrame","rect":{"x":0,"y":0,"width":130,"height":130},"offset":{"x":0,"y":0},"originalSize":{"width":130,"height":130},"rotated":false,"capInsets":[0,0,0,0],"vertices":{"rawPosition":[-65,-65,0,65,-65,0,-65,65,0,65,65,0],"indexes":[0,1,2,2,1,3],"uv":[0,130,130,130,0,0,130,0],"nuv":[0,0,1,0,0,1,1,1],"minPos":{"x":-65,"y":-65,"z":0},"maxPos":{"x":65,"y":65,"z":0}},"packable":true,"pixelsToUnit":100,"pivot":{"x":0.5,"y":0.5},"meshType":0}],[0],0,[0],[2],[12]],[[[32,"shaderEffect",[{}],[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_TEXTURE":true}]]],0,0,[0],[17],[13]],[[[33,"../framework/projectLib/psLayerEffectLib/chunkDefine/shaderEffect",[{"IS_GRAY":[false],"USE_TEXTURE":[true]}],[{"hash":3905675292,"name":"../framework/projectLib/psLayerEffectLib/chunkDefine/shaderEffect|vs:vert|fs:frag","blocks":[{"name":"ALPHA_TEST_DATA","stageFlags":16,"binding":0,"members":[{"name":"alphaThreshold","type":13,"count":1}],"defines":["USE_ALPHA_TEST"]},{"name":"InputData","stageFlags":16,"binding":1,"members":[{"name":"pureColor","type":16,"count":1},{"name":"rectFrameBKColor","type":16,"count":1},{"name":"outlineColor","type":16,"count":1},{"name":"nodeSize","type":14,"count":1},{"name":"GrayEnable","type":13,"count":1},{"name":"SolidColorEnable","type":13,"count":1},{"name":"rotateAngle","type":13,"count":1},{"name":"rotateUpRatio","type":13,"count":1},{"name":"rotateDownRatio","type":13,"count":1},{"name":"RotateEnable","type":13,"count":1},{"name":"leftGradientRatio","type":13,"count":1},{"name":"rightGradientRatio","type":13,"count":1},{"name":"topGradientRatio","type":13,"count":1},{"name":"bottomGradientRatio","type":13,"count":1},{"name":"GradientEnable","type":13,"count":1},{"name":"curAngle","type":13,"count":1},{"name":"angles","type":13,"count":1},{"name":"RadiusMoveEnable","type":13,"count":1},{"name":"xLineWidth","type":13,"count":1},{"name":"yLineHeight","type":13,"count":1},{"name":"useBKColor","type":13,"count":1},{"name":"RectFrameEnable","type":13,"count":1},{"name":"ringWidth","type":13,"count":1},{"name":"RingEnable","type":13,"count":1},{"name":"widthRatio","type":13,"count":1},{"name":"curRatio","type":13,"count":1},{"name":"UVMaskEnable","type":13,"count":1},{"name":"xOffset","type":13,"count":1},{"name":"UVOffsetEnable","type":13,"count":1},{"name":"WaveA","type":13,"count":1},{"name":"WaveT","type":13,"count":1},{"name":"WaveLineWidth","type":13,"count":1},{"name":"WaveOffset","type":13,"count":1},{"name":"WaveSita","type":13,"count":1},{"name":"elapseTime","type":13,"count":1},{"name":"WaveEnable","type":13,"count":1},{"name":"H","type":13,"count":1},{"name":"S","type":13,"count":1},{"name":"L","type":13,"count":1},{"name":"HSLEnable","type":13,"count":1},{"name":"splitSolid","type":13,"count":1},{"name":"splitEmpty","type":13,"count":1},{"name":"splitOffset","type":13,"count":1},{"name":"SplitEnable","type":13,"count":1},{"name":"outlineWidth","type":13,"count":1},{"name":"outlineOnly","type":13,"count":1},{"name":"OutlineEnable","type":13,"count":1}],"defines":[]}],"samplerTextures":[],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_texCoord","format":21,"location":1,"defines":[]},{"name":"a_color","format":44,"location":2,"defines":[]}],"fragColors":[{"name":"cc_FragColor","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"descriptors":[{"rate":0,"blocks":[{"name":"CCLocal","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_matWorld","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matWorldIT","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_lightingMapUVParam","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_localShadowBias","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeData1","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeData2","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeBlendData1","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeBlendData2","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["USE_LOCAL"]}],"samplerTextures":[{"name":"cc_spriteTexture","typename":"sampler2D","type":28,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["USE_TEXTURE"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":1,"blocks":[{"name":"ALPHA_TEST_DATA","stageFlags":16,"binding":0,"members":[{"name":"alphaThreshold","type":13,"count":1}],"defines":["USE_ALPHA_TEST"]},{"name":"InputData","stageFlags":16,"binding":1,"members":[{"name":"pureColor","type":16,"count":1},{"name":"rectFrameBKColor","type":16,"count":1},{"name":"outlineColor","type":16,"count":1},{"name":"nodeSize","type":14,"count":1},{"name":"GrayEnable","type":13,"count":1},{"name":"SolidColorEnable","type":13,"count":1},{"name":"rotateAngle","type":13,"count":1},{"name":"rotateUpRatio","type":13,"count":1},{"name":"rotateDownRatio","type":13,"count":1},{"name":"RotateEnable","type":13,"count":1},{"name":"leftGradientRatio","type":13,"count":1},{"name":"rightGradientRatio","type":13,"count":1},{"name":"topGradientRatio","type":13,"count":1},{"name":"bottomGradientRatio","type":13,"count":1},{"name":"GradientEnable","type":13,"count":1},{"name":"curAngle","type":13,"count":1},{"name":"angles","type":13,"count":1},{"name":"RadiusMoveEnable","type":13,"count":1},{"name":"xLineWidth","type":13,"count":1},{"name":"yLineHeight","type":13,"count":1},{"name":"useBKColor","type":13,"count":1},{"name":"RectFrameEnable","type":13,"count":1},{"name":"ringWidth","type":13,"count":1},{"name":"RingEnable","type":13,"count":1},{"name":"widthRatio","type":13,"count":1},{"name":"curRatio","type":13,"count":1},{"name":"UVMaskEnable","type":13,"count":1},{"name":"xOffset","type":13,"count":1},{"name":"UVOffsetEnable","type":13,"count":1},{"name":"WaveA","type":13,"count":1},{"name":"WaveT","type":13,"count":1},{"name":"WaveLineWidth","type":13,"count":1},{"name":"WaveOffset","type":13,"count":1},{"name":"WaveSita","type":13,"count":1},{"name":"elapseTime","type":13,"count":1},{"name":"WaveEnable","type":13,"count":1},{"name":"H","type":13,"count":1},{"name":"S","type":13,"count":1},{"name":"L","type":13,"count":1},{"name":"HSLEnable","type":13,"count":1},{"name":"splitSolid","type":13,"count":1},{"name":"splitEmpty","type":13,"count":1},{"name":"splitOffset","type":13,"count":1},{"name":"SplitEnable","type":13,"count":1},{"name":"outlineWidth","type":13,"count":1},{"name":"outlineOnly","type":13,"count":1},{"name":"OutlineEnable","type":13,"count":1}],"defines":[]}],"samplerTextures":[],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":2,"blocks":[],"samplerTextures":[],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":3,"blocks":[{"name":"CCGlobal","stageFlags":1,"tags":{"builtin":"global"},"members":[{"name":"cc_time","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_screenSize","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_nativeSize","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_probeInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_debug_view_mode","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCCamera","stageFlags":1,"tags":{"builtin":"global"},"members":[{"name":"cc_matView","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matProjInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewProjInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_cameraPos","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_surfaceTransform","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_screenScale","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_exposure","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_mainLitDir","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_mainLitColor","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_ambientSky","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_ambientGround","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogColor","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogBase","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogAdd","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_nearFar","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_viewPort","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]}],"samplerTextures":[],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]}],"glsl3":{"vert":"\nprecision highp float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n  mediump vec4 cc_probeInfo;\n  mediump vec4 cc_debug_view_mode;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_surfaceTransform;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#if USE_LOCAL\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n    highp vec4 cc_localShadowBias;\n    highp vec4 cc_reflectionProbeData1;\n    highp vec4 cc_reflectionProbeData2;\n    highp vec4 cc_reflectionProbeBlendData1;\n    highp vec4 cc_reflectionProbeBlendData2;\n  };\n#endif\n#if SAMPLE_FROM_RT\n  #define QUATER_PI         0.78539816340\n  #define HALF_PI           1.57079632679\n  #define PI                3.14159265359\n  #define PI2               6.28318530718\n  #define PI4               12.5663706144\n  #define INV_QUATER_PI     1.27323954474\n  #define INV_HALF_PI       0.63661977237\n  #define INV_PI            0.31830988618\n  #define INV_PI2           0.15915494309\n  #define INV_PI4           0.07957747155\n  #define EPSILON           1e-6\n  #define EPSILON_LOWP      1e-4\n  #define LOG2              1.442695\n  #define EXP_VALUE         2.71828183\n  #define FP_MAX            65504.0\n  #define FP_SCALE          0.0009765625\n  #define FP_SCALE_INV      1024.0\n  #define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n      #define LIGHT_MAP_TYPE_DISABLED 0\n  #define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n  #define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n  #define REFLECTION_PROBE_TYPE_NONE 0\n  #define REFLECTION_PROBE_TYPE_CUBE 1\n  #define REFLECTION_PROBE_TYPE_PLANAR 2\n  #define REFLECTION_PROBE_TYPE_BLEND 3\n  #define REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX 4\n      #define LIGHT_TYPE_DIRECTIONAL 0.0\n  #define LIGHT_TYPE_SPHERE 1.0\n  #define LIGHT_TYPE_SPOT 2.0\n  #define LIGHT_TYPE_POINT 3.0\n  #define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n  #define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n  #define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n  #define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n  #define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n  #define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n  #define TONE_MAPPING_ACES 0\n  #define TONE_MAPPING_LINEAR 1\n  #define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\n  #ifndef CC_SURFACES_DEBUG_VIEW_SINGLE\n    #define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n  #endif\n  #ifndef CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n    #define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n  #endif\n#endif\nin vec3 a_position;\nin vec2 a_texCoord;\nin vec4 a_color;\nout vec4 color;\nout vec2 uv0;\nvec4 vert () {\n  vec4 pos = vec4(a_position, 1);\n  #if USE_LOCAL\n    pos = cc_matWorld * pos;\n  #endif\n  #if USE_PIXEL_ALIGNMENT\n    pos = cc_matView * pos;\n    pos.xyz = floor(pos.xyz);\n    pos = cc_matProj * pos;\n  #else\n    pos = cc_matViewProj * pos;\n  #endif\n  uv0 = a_texCoord;\n  #if SAMPLE_FROM_RT\n    uv0 = cc_cameraPos.w > 1.0 ? vec2(uv0.x, 1.0 - uv0.y) : uv0;\n  #endif\n  color = a_color;\n  return pos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\n  precision highp float;\n  vec4 CCSampleWithAlphaSeparated(sampler2D tex, vec2 uv) {\n  #if CC_USE_EMBEDDED_ALPHA\n    return vec4(texture(tex, uv).rgb, texture(tex, uv + vec2(0.0, 0.5)).r);\n  #else\n    return texture(tex, uv);\n  #endif\n  }\n  #if USE_ALPHA_TEST\n    layout(std140) uniform ALPHA_TEST_DATA {\n      float alphaThreshold;\n    };\n  #endif\n  void ALPHA_TEST (in vec4 color) {\n    #if USE_ALPHA_TEST\n      if (color.a < alphaThreshold) discard;\n    #endif\n  }\n  void ALPHA_TEST (in float alpha) {\n    #if USE_ALPHA_TEST\n      if (alpha < alphaThreshold) discard;\n    #endif\n  }\n  in vec4 color;\n  #if USE_TEXTURE\n    in vec2 uv0;\n    uniform sampler2D cc_spriteTexture;\n  #endif\n  layout(std140) uniform InputData\n  {\n    vec4 pureColor;\n    vec4 rectFrameBKColor;\n    vec4 outlineColor;\n    vec2 nodeSize;\n    float GrayEnable;\n    float SolidColorEnable;\n    float rotateAngle;\n    float rotateUpRatio;\n    float rotateDownRatio;\n    float RotateEnable;\n    float leftGradientRatio;\n    float rightGradientRatio;\n    float topGradientRatio;\n    float bottomGradientRatio;\n    float GradientEnable;\n    float curAngle;\n    float angles;\n    float RadiusMoveEnable;\n    float xLineWidth;\n    float yLineHeight;\n    float useBKColor;\n    float RectFrameEnable;\n    float ringWidth;\n    float RingEnable;\n    float widthRatio;\n    float curRatio;\n    float UVMaskEnable;\n    float xOffset;\n    float UVOffsetEnable;\n    float WaveA;\n    float WaveT;\n    float WaveLineWidth;\n    float WaveOffset;\n    float WaveSita;\n    float elapseTime;\n    float WaveEnable;\n    float H;\n    float S;\n    float L;\n    float HSLEnable;\n    float splitSolid;\n    float splitEmpty;\n    float splitOffset;\n    float SplitEnable;\n    float outlineWidth;\n    float outlineOnly;\n    float OutlineEnable;\n  };\n  vec2 convertUV(vec2 zuv)\n  {\n    vec2 cuv = vec2(zuv.x - 0.5, 0.5 - zuv.y);\n    return cuv;\n  }\nvec4 ZKGray(vec2 zuv, vec4 zo)\n{\n    float v = 0.27 * zo.r + 0.7 * zo.g + 0.03 * zo.b;\n    zo.r = v;\n    zo.g = v;\n    zo.b = v;\n    return zo;\n}\nvec4 ZKSolidColor(vec2 zuv, vec4 zo)\n{\n    zo.rgb = pureColor.rgb;\n    return zo;\n}\nvec4 ZKRotate(vec2 zuv, vec4 zo)\n{\n    vec2 cuv = convertUV(zuv);\n    if(cuv.y > rotateUpRatio || cuv.y < rotateDownRatio)\n    {\n        zo.a = 0.0;\n        return zo;\n    }\n    float x = cuv.x * cos(radians(rotateAngle)) - cuv.y * sin(radians(rotateAngle));\n    float y = cuv.y * cos(radians(rotateAngle)) + cuv.x * sin(radians(rotateAngle));\n    vec4 tmp = CCSampleWithAlphaSeparated(cc_spriteTexture, vec2(x + 0.5, 0.5 - y));\n    zo = tmp;\n    return zo;\n}\nvec4 ZKGradient(vec2 zuv, vec4 zo)\n{\n    float mulA = 1.0;\n    if(leftGradientRatio > 0.0)\n    {\n        mulA *= smoothstep(0.0, leftGradientRatio, zuv.x);\n    }\n    if(rightGradientRatio > 0.0)\n    {\n        mulA *= (1.0 - smoothstep(1.0 - rightGradientRatio, 1.0, zuv.x));\n    }\n    if(topGradientRatio > 0.0)\n    {\n        mulA *= smoothstep(0.0, topGradientRatio, zuv.y);\n    }\n    if(bottomGradientRatio > 0.0)\n    {\n        mulA *= (1.0 - smoothstep(1.0 - bottomGradientRatio, 1.0, zuv.y));\n    }\n    zo.a *= mulA;\n    return zo;\n}\nvec4 ZKRadiusMove(vec2 zuv, vec4 zo)\n{\n    if(zo.a < 0.1)\n    {\n        return zo;\n    }\n    vec2 cuv = convertUV(zuv);\n    vec3 OA = vec3(cos(radians(curAngle)), sin(radians(curAngle)), 0.0);\n    vec3 OB = vec3(cos(radians(curAngle + angles)), sin(radians(curAngle + angles)), 0.0);\n    vec3 OC = vec3(cuv.x, cuv.y, 0.0);\n    vec3 OAToOC = cross(OA, OC);\n    vec3 OCToOB = cross(OC, OB);\n    if(OAToOC.z >= 0.0 && OCToOB.z >= 0.0)\n    {\n        float angle = degrees(acos(dot(normalize(OA), normalize(OC))));\n        float percent = 1.0;\n        if(angle < angles / 2.0)\n        {\n            percent = angle / angles;\n        }\n        else\n        {\n            percent = (angles - angle) / angles;\n        }\n        zo.a *= percent * 2.0;\n    }\n    else if(OAToOC.z < 0.0 && OCToOB.z < 0.0)\n    {\n        float angle = degrees(acos(dot(normalize(OA * -1.0), normalize(OC))));\n        float percent = 1.0;\n        if(angle < angles / 2.0)\n        {\n            percent = angle / angles;\n        }\n        else\n        {\n            percent = (angles - angle) / angles;\n        }\n        zo.a *= percent * 2.0;\n    }\n    else\n    {\n        zo.a = 0.0;\n    }\n    return zo;\n}\nvec4 ZKRectFrame(vec2 zuv, vec4 zo)\n{\n    vec2 cuv = convertUV(zuv);\n    float xDis = abs(cuv.x);\n    float yDis = abs(cuv.y);\n    float xP = xLineWidth / nodeSize.x;\n    float yP = yLineHeight / nodeSize.y;\n    float xV = step(0.5 - xP, xDis);\n    float yV = step(0.5 - yP, yDis);\n    float alpha = (step(0.5, (xV + yV)) * 1.0);\n    if(alpha < 0.5)\n    {\n        if(useBKColor > 0.5)\n        {\n            zo.rgb = rectFrameBKColor.rgb;\n            zo.a *= rectFrameBKColor.a;\n        }\n        else\n        {\n            zo.a *= alpha;\n        }\n    }\n    else\n    {\n        zo.a *= alpha;\n    }\n    return zo;\n}\nvec4 ZKRing(vec2 zuv, vec4 zo)\n{\n    vec2 cuv = convertUV(zuv);\n    float len = sqrt( (cuv.x * cuv.x) + (cuv.y * cuv.y) );\n    float ringRadius = 0.5 - ringWidth / nodeSize.x;\n    float v = smoothstep(ringRadius - 0.005, ringRadius, len) - smoothstep(0.5 - 0.005, 0.5, len);\n    zo.a *= v;\n    return zo;\n}\nvec4 ZKUVMask(vec2 zuv, vec4 zo)\n{\n    float startRatio = curRatio;\n    float endRatio = curRatio + widthRatio;\n    float leftEndRatio = startRatio + widthRatio / 4.0;\n    float rightStartRatio = endRatio - widthRatio / 4.0;\n    if(zuv.x >= startRatio && zuv.x <= endRatio)\n    {\n        if(zuv.x >= startRatio && zuv.x <= leftEndRatio)\n        {\n        float leftOpacity = smoothstep(startRatio, leftEndRatio, zuv.x);\n        zo.a *= leftOpacity;\n        }\n        else if(zuv.x >= rightStartRatio && zuv.x <= endRatio)\n        {\n        float rightOpacity = smoothstep(rightStartRatio, endRatio, zuv.x);\n        zo.a *= (1.0 - rightOpacity);\n        }\n    }\n    else\n    {\n        zo.a = 0.0;\n    }\n    return zo;\n}\nvec4 ZKUVOffset(vec2 zuv, vec4 zo)\n{\n    float x = fract(zuv.x + xOffset);\n    zo = CCSampleWithAlphaSeparated(cc_spriteTexture, vec2(x, zuv.y));\n    float alphaTh = 0.7;\n    float ratio = (1.0 / (1.0 - alphaTh));\n    if(zuv.x > alphaTh)\n    {\n        float transferX = (zuv.x - alphaTh) * ratio;\n        float transferXA = (1.0 - transferX);\n        zo.a *= transferXA;\n    }\n    else if(zuv.x < (1.0 - alphaTh))\n    {\n        float transferX = zuv.x * ratio;\n        float transferXA = transferX;\n        zo.a *= transferXA;\n    }\n    return zo;\n}\nvec4 ZKWave(vec2 zuv, vec4 zo)\n{\n    vec2 uv = convertUV(zuv);\n    float y = WaveA * (1.0 - zuv.x) * sin((elapseTime / 1.3 + uv.x) * (6.28 / WaveT) + WaveSita * WaveT) + WaveOffset;\n    float offset = WaveLineWidth;\n    if(uv.y > (y - offset) && uv.y < (y + offset))\n    {\n    }\n    else\n    {\n        zo.a = 0.0;\n    }\n    return zo;\n}\nfloat RgbMax(in vec4 c)\n{\n    return max(max(c.r, c.g), c.b);\n}\nfloat RgbMin(in vec4 c)\n{\n    return min(min(c.r, c.g), c.b);\n}\nvec4 RGBToHSL(in vec4 rgb)\n{\n    vec4 hsl = vec4(0., 0., 0., rgb.a);\n    float cmax, cmin, dt;\n    cmax = RgbMax(rgb);\n    cmin = RgbMin(rgb);\n    hsl.z = (cmax + cmin) / 2.0;\n    if (cmax == cmin)\n    {\n        hsl.x = -1.0;\n    }\n    else\n    {\n        if (hsl.z <= 0.5)\n        hsl.y = (cmax - cmin) / (cmax + cmin);\n        else\n        hsl.y = (cmax - cmin) / (2.0 - cmax - cmin);\n        dt = cmax - cmin;\n        if (dt == 0.0)\n        dt = 1.0;\n        if (rgb.r == cmax)\n        {\n            hsl.x = (rgb.g - rgb.b) / dt;\n        }\n        else if (rgb.g == cmax)\n        {\n            hsl.x = 2.0 + (rgb.b - rgb.r) / dt;\n        }\n        else\n        {\n            hsl.x = 4.0 + (rgb.r - rgb.g) / dt;\n        }\n        hsl.x /= 6.0;\n        if (hsl.x < 0.0)\n        hsl.x += 1.0;\n    }\n    return hsl;\n}\nfloat HSLValue(in float n1, in float n2, in float hue)\n{\n    float val;\n    if (hue > 6.0)\n        hue -= 6.0;\n    else if (hue < 0.0)\n        hue += 6.0;\n    if (hue < 1.0)\n        val = n1 + (n2 - n1) * hue;\n    else if (hue < 3.0)\n        val = n2;\n    else if (hue < 4.0)\n        val = n1 + (n2 - n1) * (4.0 - hue);\n    else\n        val = n1;\n    return val;\n}\nvec4 HSLToRGB(in vec4 hsl)\n{\n    vec4 rgb = vec4(0., 0., 0., hsl.w);\n    if (hsl.y == 0.0)\n    {\n        rgb.r = rgb.g = rgb.b = hsl.z;\n    }\n    else\n    {\n        float m1, m2;\n        if (hsl.z <= 0.5)\n            m2 = hsl.z * (1.0 + hsl.y);\n        else\n            m2 = hsl.z + hsl.y - hsl.z * hsl.y;\n        m1 = 2.0 * hsl.z - m2;\n        rgb.r = HSLValue(m1, m2, hsl.x * 6.0 + 2.0);\n        rgb.g = HSLValue(m1, m2, hsl.x * 6.0);\n        rgb.b = HSLValue(m1, m2, hsl.x * 6.0 - 2.0);\n    }\n    return rgb;\n}\nvoid HSLBalance(inout vec4 hsl)\n{\n    float v = H / 180.0 / 2.0;\n    hsl.x += v;\n    if (hsl.x < 0.0)\n    {\n        hsl.x += 1.0;\n    }\n    else if (hsl.x > 1.0)\n    {\n        hsl.x -= 1.0;\n    }\n    v = S / 100.0;\n    hsl.y *= (v + 1.0);\n    hsl.y = clamp(hsl.y, 0.0, 1.0);\n    v = L / 100.0 / 2.0;\n    if (v < 0.0)\n    {\n        hsl.z *= (v + 1.0);\n    }\n    else\n    {\n        hsl.z += v * (1.0 - hsl.z);\n    }\n}\nvec4 ZKHSL(vec2 uv_0, vec4 zo)\n{\n    vec4 hsl = RGBToHSL(zo);\n    HSLBalance(hsl);\n    zo = HSLToRGB(hsl);\n    return zo;\n}\nvec4 ZKSplit(vec2 zuv, vec4 zo)\n{\n    float solid = splitSolid;\n    float empty = splitEmpty;\n    float offset = splitOffset;\n    float cur = zuv.x;\n    float n = floor((cur) / (solid + empty));\n    float start = n * (solid + empty) + offset;\n    start = fract(start);\n    float end = start + solid;\n    end = fract(end);\n    int mark = 0;\n    if(start < end)\n    {\n        if(start < cur && cur < end)\n        {\n            mark = 1;\n        }\n    }\n    else\n    {\n        if(cur < end)\n        {\n            mark = 1;\n        }\n        float outO = fract(cur + offset);\n        if(outO < end)\n        {\n        }\n    }\n    if(mark == 0)\n    {\n        zo.a = 0.;\n    }\n    return zo;\n}\nvec4 ZKOutline(vec2 zuv, vec4 zo)\n{\n    vec2 scale = vec2(outlineWidth / nodeSize.x, outlineWidth / nodeSize.y);\n    highp float sx1 = scale.x * 0.7;\n    highp float sy1 = scale.y * 0.7;\n    highp float sx2 = scale.x * 1.44;\n    highp float sy2 = scale.y * 1.44;\n    highp float sx3 = scale.x * 1.91;\n    highp float sy3 = scale.y * 1.91;\n    highp float sx4 = scale.x * 2.0;\n    highp float sy4 = scale.y * 2.0;\n  mediump float sum = 0.0;\n    vec2 v_texcoord = zuv;\n    sum += CCSampleWithAlphaSeparated(cc_spriteTexture, v_texcoord + vec2( +sx4,  0.0)).a;\n    sum += CCSampleWithAlphaSeparated(cc_spriteTexture, v_texcoord + vec2( +sx3, +sy1)).a;\n    sum += CCSampleWithAlphaSeparated(cc_spriteTexture, v_texcoord + vec2( +sx2, +sy2)).a;\n    sum += CCSampleWithAlphaSeparated(cc_spriteTexture, v_texcoord + vec2( +sx1, +sy3)).a;\n    sum += CCSampleWithAlphaSeparated(cc_spriteTexture, v_texcoord + vec2(  0.0, +sy4)).a;\n    sum += CCSampleWithAlphaSeparated(cc_spriteTexture, v_texcoord + vec2( -sx1, +sy3)).a;\n    sum += CCSampleWithAlphaSeparated(cc_spriteTexture, v_texcoord + vec2( -sx2, +sy2)).a;\n    sum += CCSampleWithAlphaSeparated(cc_spriteTexture, v_texcoord + vec2( -sx3, +sy1)).a;\n    sum += CCSampleWithAlphaSeparated(cc_spriteTexture, v_texcoord + vec2( -sx4,  0.0)).a;\n    sum += CCSampleWithAlphaSeparated(cc_spriteTexture, v_texcoord + vec2( -sx3, -sy1)).a;\n    sum += CCSampleWithAlphaSeparated(cc_spriteTexture, v_texcoord + vec2( -sx2, -sy2)).a;\n    sum += CCSampleWithAlphaSeparated(cc_spriteTexture, v_texcoord + vec2( -sx1, -sy3)).a;\n    sum += CCSampleWithAlphaSeparated(cc_spriteTexture, v_texcoord + vec2(  0.0, -sy4)).a;\n    sum += CCSampleWithAlphaSeparated(cc_spriteTexture, v_texcoord + vec2( +sx1, -sy3)).a;\n    sum += CCSampleWithAlphaSeparated(cc_spriteTexture, v_texcoord + vec2( +sx2, -sy2)).a;\n    sum += CCSampleWithAlphaSeparated(cc_spriteTexture, v_texcoord + vec2( +sx3, -sy1)).a;\n    sum -= 1.0;\n    sum *= 0.5;\n    sum = clamp(sum, 0.0, 1.0);\n  mediump vec4 icon = CCSampleWithAlphaSeparated(cc_spriteTexture, v_texcoord);\n  mediump vec4 outline = vec4(outlineColor.rgb, sum * outlineColor.a);\n    float iconA = icon.a;\n  mediump vec4 result = vec4(mix(outline.rgb, icon.rgb, iconA), iconA + (1.0 - iconA) * outline.a);\n    if(outlineOnly > 0.5)\n    {\n        sum *= (1.0 - iconA);\n        result = vec4(outlineColor.rgb, outlineColor.a * sum);\n    }\n    zo = result * color;\n    return zo;\n}\n  vec4 frag () {\n    vec4 o = vec4(1, 1, 1, 1);\n    #if USE_TEXTURE\n      o *= CCSampleWithAlphaSeparated(cc_spriteTexture, uv0);\n      #if IS_GRAY\n        float gray  = 0.2126 * o.r + 0.7152 * o.g + 0.0722 * o.b;\n        o.r = o.g = o.b = gray;\n      #endif\n    #endif\n    o *= color;\n    if(GrayEnable > 0.5){o = ZKGray(uv0, o);}\n    if(RotateEnable > 0.5){o = ZKRotate(uv0, o);}\n    if(GradientEnable > 0.5){o = ZKGradient(uv0, o);}\n    if(RadiusMoveEnable > 0.5){o = ZKRadiusMove(uv0, o);}\n    if(RectFrameEnable > 0.5){o = ZKRectFrame(uv0, o);}\n    if(RingEnable > 0.5){o = ZKRing(uv0, o);}\n    if(UVMaskEnable > 0.5){o = ZKUVMask(uv0, o);}\n    if(UVOffsetEnable > 0.5){o = ZKUVOffset(uv0, o);}\n    if(WaveEnable > 0.5){o = ZKWave(uv0, o);}\n    if(HSLEnable > 0.5){o = ZKHSL(uv0, o);}\n    if(SplitEnable > 0.5){o = ZKSplit(uv0, o);}\n    if(OutlineEnable > 0.5){o = ZKOutline(uv0, o);}\n        if(SolidColorEnable > 0.5){o = ZKSolidColor(uv0, o);}\n    ALPHA_TEST(o);\n    return o;\n  }\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl1":{"vert":"\nprecision highp float;\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matProj;\n  uniform highp mat4 cc_matViewProj;\n  uniform highp vec4 cc_cameraPos;\n#if USE_LOCAL\n  uniform highp mat4 cc_matWorld;\n#endif\n#if SAMPLE_FROM_RT\n  #define QUATER_PI         0.78539816340\n  #define HALF_PI           1.57079632679\n  #define PI                3.14159265359\n  #define PI2               6.28318530718\n  #define PI4               12.5663706144\n  #define INV_QUATER_PI     1.27323954474\n  #define INV_HALF_PI       0.63661977237\n  #define INV_PI            0.31830988618\n  #define INV_PI2           0.15915494309\n  #define INV_PI4           0.07957747155\n  #define EPSILON           1e-6\n  #define EPSILON_LOWP      1e-4\n  #define LOG2              1.442695\n  #define EXP_VALUE         2.71828183\n  #define FP_MAX            65504.0\n  #define FP_SCALE          0.0009765625\n  #define FP_SCALE_INV      1024.0\n  #define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n      #define LIGHT_MAP_TYPE_DISABLED 0\n  #define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n  #define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n  #define REFLECTION_PROBE_TYPE_NONE 0\n  #define REFLECTION_PROBE_TYPE_CUBE 1\n  #define REFLECTION_PROBE_TYPE_PLANAR 2\n  #define REFLECTION_PROBE_TYPE_BLEND 3\n  #define REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX 4\n      #define LIGHT_TYPE_DIRECTIONAL 0.0\n  #define LIGHT_TYPE_SPHERE 1.0\n  #define LIGHT_TYPE_SPOT 2.0\n  #define LIGHT_TYPE_POINT 3.0\n  #define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n  #define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n  #define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n  #define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n  #define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n  #define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n  #define TONE_MAPPING_ACES 0\n  #define TONE_MAPPING_LINEAR 1\n  #define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\n  #ifndef CC_SURFACES_DEBUG_VIEW_SINGLE\n    #define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n  #endif\n  #ifndef CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n    #define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n  #endif\n#endif\nattribute vec3 a_position;\nattribute vec2 a_texCoord;\nattribute vec4 a_color;\nvarying vec4 color;\nvarying vec2 uv0;\nvec4 vert () {\n  vec4 pos = vec4(a_position, 1);\n  #if USE_LOCAL\n    pos = cc_matWorld * pos;\n  #endif\n  #if USE_PIXEL_ALIGNMENT\n    pos = cc_matView * pos;\n    pos.xyz = floor(pos.xyz);\n    pos = cc_matProj * pos;\n  #else\n    pos = cc_matViewProj * pos;\n  #endif\n  uv0 = a_texCoord;\n  #if SAMPLE_FROM_RT\n    uv0 = cc_cameraPos.w > 1.0 ? vec2(uv0.x, 1.0 - uv0.y) : uv0;\n  #endif\n  color = a_color;\n  return pos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\n  precision highp float;\n  vec4 CCSampleWithAlphaSeparated(sampler2D tex, vec2 uv) {\n  #if CC_USE_EMBEDDED_ALPHA\n    return vec4(texture2D(tex, uv).rgb, texture2D(tex, uv + vec2(0.0, 0.5)).r);\n  #else\n    return texture2D(tex, uv);\n  #endif\n  }\n  #if USE_ALPHA_TEST\n          uniform float alphaThreshold;\n  #endif\n  void ALPHA_TEST (in vec4 color) {\n    #if USE_ALPHA_TEST\n      if (color.a < alphaThreshold) discard;\n    #endif\n  }\n  void ALPHA_TEST (in float alpha) {\n    #if USE_ALPHA_TEST\n      if (alpha < alphaThreshold) discard;\n    #endif\n  }\n  varying vec4 color;\n  #if USE_TEXTURE\n    varying vec2 uv0;\n    uniform sampler2D cc_spriteTexture;\n  #endif\n       uniform vec4 pureColor;\n     uniform vec4 rectFrameBKColor;\n     uniform vec4 outlineColor;\n     uniform vec2 nodeSize;\n     uniform float GrayEnable;\n     uniform float SolidColorEnable;\n     uniform float rotateAngle;\n     uniform float rotateUpRatio;\n     uniform float rotateDownRatio;\n     uniform float RotateEnable;\n     uniform float leftGradientRatio;\n     uniform float rightGradientRatio;\n     uniform float topGradientRatio;\n     uniform float bottomGradientRatio;\n     uniform float GradientEnable;\n     uniform float curAngle;\n     uniform float angles;\n     uniform float RadiusMoveEnable;\n     uniform float xLineWidth;\n     uniform float yLineHeight;\n     uniform float useBKColor;\n     uniform float RectFrameEnable;\n     uniform float ringWidth;\n     uniform float RingEnable;\n     uniform float widthRatio;\n     uniform float curRatio;\n     uniform float UVMaskEnable;\n     uniform float xOffset;\n     uniform float UVOffsetEnable;\n     uniform float WaveA;\n     uniform float WaveT;\n     uniform float WaveLineWidth;\n     uniform float WaveOffset;\n     uniform float WaveSita;\n     uniform float elapseTime;\n     uniform float WaveEnable;\n     uniform float H;\n     uniform float S;\n     uniform float L;\n     uniform float HSLEnable;\n     uniform float splitSolid;\n     uniform float splitEmpty;\n     uniform float splitOffset;\n     uniform float SplitEnable;\n     uniform float outlineWidth;\n     uniform float outlineOnly;\n     uniform float OutlineEnable;\n  vec2 convertUV(vec2 zuv)\n  {\n    vec2 cuv = vec2(zuv.x - 0.5, 0.5 - zuv.y);\n    return cuv;\n  }\nvec4 ZKGray(vec2 zuv, vec4 zo)\n{\n    float v = 0.27 * zo.r + 0.7 * zo.g + 0.03 * zo.b;\n    zo.r = v;\n    zo.g = v;\n    zo.b = v;\n    return zo;\n}\nvec4 ZKSolidColor(vec2 zuv, vec4 zo)\n{\n    zo.rgb = pureColor.rgb;\n    return zo;\n}\nvec4 ZKRotate(vec2 zuv, vec4 zo)\n{\n    vec2 cuv = convertUV(zuv);\n    if(cuv.y > rotateUpRatio || cuv.y < rotateDownRatio)\n    {\n        zo.a = 0.0;\n        return zo;\n    }\n    float x = cuv.x * cos(radians(rotateAngle)) - cuv.y * sin(radians(rotateAngle));\n    float y = cuv.y * cos(radians(rotateAngle)) + cuv.x * sin(radians(rotateAngle));\n    vec4 tmp = CCSampleWithAlphaSeparated(cc_spriteTexture, vec2(x + 0.5, 0.5 - y));\n    zo = tmp;\n    return zo;\n}\nvec4 ZKGradient(vec2 zuv, vec4 zo)\n{\n    float mulA = 1.0;\n    if(leftGradientRatio > 0.0)\n    {\n        mulA *= smoothstep(0.0, leftGradientRatio, zuv.x);\n    }\n    if(rightGradientRatio > 0.0)\n    {\n        mulA *= (1.0 - smoothstep(1.0 - rightGradientRatio, 1.0, zuv.x));\n    }\n    if(topGradientRatio > 0.0)\n    {\n        mulA *= smoothstep(0.0, topGradientRatio, zuv.y);\n    }\n    if(bottomGradientRatio > 0.0)\n    {\n        mulA *= (1.0 - smoothstep(1.0 - bottomGradientRatio, 1.0, zuv.y));\n    }\n    zo.a *= mulA;\n    return zo;\n}\nvec4 ZKRadiusMove(vec2 zuv, vec4 zo)\n{\n    if(zo.a < 0.1)\n    {\n        return zo;\n    }\n    vec2 cuv = convertUV(zuv);\n    vec3 OA = vec3(cos(radians(curAngle)), sin(radians(curAngle)), 0.0);\n    vec3 OB = vec3(cos(radians(curAngle + angles)), sin(radians(curAngle + angles)), 0.0);\n    vec3 OC = vec3(cuv.x, cuv.y, 0.0);\n    vec3 OAToOC = cross(OA, OC);\n    vec3 OCToOB = cross(OC, OB);\n    if(OAToOC.z >= 0.0 && OCToOB.z >= 0.0)\n    {\n        float angle = degrees(acos(dot(normalize(OA), normalize(OC))));\n        float percent = 1.0;\n        if(angle < angles / 2.0)\n        {\n            percent = angle / angles;\n        }\n        else\n        {\n            percent = (angles - angle) / angles;\n        }\n        zo.a *= percent * 2.0;\n    }\n    else if(OAToOC.z < 0.0 && OCToOB.z < 0.0)\n    {\n        float angle = degrees(acos(dot(normalize(OA * -1.0), normalize(OC))));\n        float percent = 1.0;\n        if(angle < angles / 2.0)\n        {\n            percent = angle / angles;\n        }\n        else\n        {\n            percent = (angles - angle) / angles;\n        }\n        zo.a *= percent * 2.0;\n    }\n    else\n    {\n        zo.a = 0.0;\n    }\n    return zo;\n}\nvec4 ZKRectFrame(vec2 zuv, vec4 zo)\n{\n    vec2 cuv = convertUV(zuv);\n    float xDis = abs(cuv.x);\n    float yDis = abs(cuv.y);\n    float xP = xLineWidth / nodeSize.x;\n    float yP = yLineHeight / nodeSize.y;\n    float xV = step(0.5 - xP, xDis);\n    float yV = step(0.5 - yP, yDis);\n    float alpha = (step(0.5, (xV + yV)) * 1.0);\n    if(alpha < 0.5)\n    {\n        if(useBKColor > 0.5)\n        {\n            zo.rgb = rectFrameBKColor.rgb;\n            zo.a *= rectFrameBKColor.a;\n        }\n        else\n        {\n            zo.a *= alpha;\n        }\n    }\n    else\n    {\n        zo.a *= alpha;\n    }\n    return zo;\n}\nvec4 ZKRing(vec2 zuv, vec4 zo)\n{\n    vec2 cuv = convertUV(zuv);\n    float len = sqrt( (cuv.x * cuv.x) + (cuv.y * cuv.y) );\n    float ringRadius = 0.5 - ringWidth / nodeSize.x;\n    float v = smoothstep(ringRadius - 0.005, ringRadius, len) - smoothstep(0.5 - 0.005, 0.5, len);\n    zo.a *= v;\n    return zo;\n}\nvec4 ZKUVMask(vec2 zuv, vec4 zo)\n{\n    float startRatio = curRatio;\n    float endRatio = curRatio + widthRatio;\n    float leftEndRatio = startRatio + widthRatio / 4.0;\n    float rightStartRatio = endRatio - widthRatio / 4.0;\n    if(zuv.x >= startRatio && zuv.x <= endRatio)\n    {\n        if(zuv.x >= startRatio && zuv.x <= leftEndRatio)\n        {\n        float leftOpacity = smoothstep(startRatio, leftEndRatio, zuv.x);\n        zo.a *= leftOpacity;\n        }\n        else if(zuv.x >= rightStartRatio && zuv.x <= endRatio)\n        {\n        float rightOpacity = smoothstep(rightStartRatio, endRatio, zuv.x);\n        zo.a *= (1.0 - rightOpacity);\n        }\n    }\n    else\n    {\n        zo.a = 0.0;\n    }\n    return zo;\n}\nvec4 ZKUVOffset(vec2 zuv, vec4 zo)\n{\n    float x = fract(zuv.x + xOffset);\n    zo = CCSampleWithAlphaSeparated(cc_spriteTexture, vec2(x, zuv.y));\n    float alphaTh = 0.7;\n    float ratio = (1.0 / (1.0 - alphaTh));\n    if(zuv.x > alphaTh)\n    {\n        float transferX = (zuv.x - alphaTh) * ratio;\n        float transferXA = (1.0 - transferX);\n        zo.a *= transferXA;\n    }\n    else if(zuv.x < (1.0 - alphaTh))\n    {\n        float transferX = zuv.x * ratio;\n        float transferXA = transferX;\n        zo.a *= transferXA;\n    }\n    return zo;\n}\nvec4 ZKWave(vec2 zuv, vec4 zo)\n{\n    vec2 uv = convertUV(zuv);\n    float y = WaveA * (1.0 - zuv.x) * sin((elapseTime / 1.3 + uv.x) * (6.28 / WaveT) + WaveSita * WaveT) + WaveOffset;\n    float offset = WaveLineWidth;\n    if(uv.y > (y - offset) && uv.y < (y + offset))\n    {\n    }\n    else\n    {\n        zo.a = 0.0;\n    }\n    return zo;\n}\nfloat RgbMax(in vec4 c)\n{\n    return max(max(c.r, c.g), c.b);\n}\nfloat RgbMin(in vec4 c)\n{\n    return min(min(c.r, c.g), c.b);\n}\nvec4 RGBToHSL(in vec4 rgb)\n{\n    vec4 hsl = vec4(0., 0., 0., rgb.a);\n    float cmax, cmin, dt;\n    cmax = RgbMax(rgb);\n    cmin = RgbMin(rgb);\n    hsl.z = (cmax + cmin) / 2.0;\n    if (cmax == cmin)\n    {\n        hsl.x = -1.0;\n    }\n    else\n    {\n        if (hsl.z <= 0.5)\n        hsl.y = (cmax - cmin) / (cmax + cmin);\n        else\n        hsl.y = (cmax - cmin) / (2.0 - cmax - cmin);\n        dt = cmax - cmin;\n        if (dt == 0.0)\n        dt = 1.0;\n        if (rgb.r == cmax)\n        {\n            hsl.x = (rgb.g - rgb.b) / dt;\n        }\n        else if (rgb.g == cmax)\n        {\n            hsl.x = 2.0 + (rgb.b - rgb.r) / dt;\n        }\n        else\n        {\n            hsl.x = 4.0 + (rgb.r - rgb.g) / dt;\n        }\n        hsl.x /= 6.0;\n        if (hsl.x < 0.0)\n        hsl.x += 1.0;\n    }\n    return hsl;\n}\nfloat HSLValue(in float n1, in float n2, in float hue)\n{\n    float val;\n    if (hue > 6.0)\n        hue -= 6.0;\n    else if (hue < 0.0)\n        hue += 6.0;\n    if (hue < 1.0)\n        val = n1 + (n2 - n1) * hue;\n    else if (hue < 3.0)\n        val = n2;\n    else if (hue < 4.0)\n        val = n1 + (n2 - n1) * (4.0 - hue);\n    else\n        val = n1;\n    return val;\n}\nvec4 HSLToRGB(in vec4 hsl)\n{\n    vec4 rgb = vec4(0., 0., 0., hsl.w);\n    if (hsl.y == 0.0)\n    {\n        rgb.r = rgb.g = rgb.b = hsl.z;\n    }\n    else\n    {\n        float m1, m2;\n        if (hsl.z <= 0.5)\n            m2 = hsl.z * (1.0 + hsl.y);\n        else\n            m2 = hsl.z + hsl.y - hsl.z * hsl.y;\n        m1 = 2.0 * hsl.z - m2;\n        rgb.r = HSLValue(m1, m2, hsl.x * 6.0 + 2.0);\n        rgb.g = HSLValue(m1, m2, hsl.x * 6.0);\n        rgb.b = HSLValue(m1, m2, hsl.x * 6.0 - 2.0);\n    }\n    return rgb;\n}\nvoid HSLBalance(inout vec4 hsl)\n{\n    float v = H / 180.0 / 2.0;\n    hsl.x += v;\n    if (hsl.x < 0.0)\n    {\n        hsl.x += 1.0;\n    }\n    else if (hsl.x > 1.0)\n    {\n        hsl.x -= 1.0;\n    }\n    v = S / 100.0;\n    hsl.y *= (v + 1.0);\n    hsl.y = clamp(hsl.y, 0.0, 1.0);\n    v = L / 100.0 / 2.0;\n    if (v < 0.0)\n    {\n        hsl.z *= (v + 1.0);\n    }\n    else\n    {\n        hsl.z += v * (1.0 - hsl.z);\n    }\n}\nvec4 ZKHSL(vec2 uv_0, vec4 zo)\n{\n    vec4 hsl = RGBToHSL(zo);\n    HSLBalance(hsl);\n    zo = HSLToRGB(hsl);\n    return zo;\n}\nvec4 ZKSplit(vec2 zuv, vec4 zo)\n{\n    float solid = splitSolid;\n    float empty = splitEmpty;\n    float offset = splitOffset;\n    float cur = zuv.x;\n    float n = floor((cur) / (solid + empty));\n    float start = n * (solid + empty) + offset;\n    start = fract(start);\n    float end = start + solid;\n    end = fract(end);\n    int mark = 0;\n    if(start < end)\n    {\n        if(start < cur && cur < end)\n        {\n            mark = 1;\n        }\n    }\n    else\n    {\n        if(cur < end)\n        {\n            mark = 1;\n        }\n        float outO = fract(cur + offset);\n        if(outO < end)\n        {\n        }\n    }\n    if(mark == 0)\n    {\n        zo.a = 0.;\n    }\n    return zo;\n}\nvec4 ZKOutline(vec2 zuv, vec4 zo)\n{\n    vec2 scale = vec2(outlineWidth / nodeSize.x, outlineWidth / nodeSize.y);\n    highp float sx1 = scale.x * 0.7;\n    highp float sy1 = scale.y * 0.7;\n    highp float sx2 = scale.x * 1.44;\n    highp float sy2 = scale.y * 1.44;\n    highp float sx3 = scale.x * 1.91;\n    highp float sy3 = scale.y * 1.91;\n    highp float sx4 = scale.x * 2.0;\n    highp float sy4 = scale.y * 2.0;\n  mediump float sum = 0.0;\n    vec2 v_texcoord = zuv;\n    sum += CCSampleWithAlphaSeparated(cc_spriteTexture, v_texcoord + vec2( +sx4,  0.0)).a;\n    sum += CCSampleWithAlphaSeparated(cc_spriteTexture, v_texcoord + vec2( +sx3, +sy1)).a;\n    sum += CCSampleWithAlphaSeparated(cc_spriteTexture, v_texcoord + vec2( +sx2, +sy2)).a;\n    sum += CCSampleWithAlphaSeparated(cc_spriteTexture, v_texcoord + vec2( +sx1, +sy3)).a;\n    sum += CCSampleWithAlphaSeparated(cc_spriteTexture, v_texcoord + vec2(  0.0, +sy4)).a;\n    sum += CCSampleWithAlphaSeparated(cc_spriteTexture, v_texcoord + vec2( -sx1, +sy3)).a;\n    sum += CCSampleWithAlphaSeparated(cc_spriteTexture, v_texcoord + vec2( -sx2, +sy2)).a;\n    sum += CCSampleWithAlphaSeparated(cc_spriteTexture, v_texcoord + vec2( -sx3, +sy1)).a;\n    sum += CCSampleWithAlphaSeparated(cc_spriteTexture, v_texcoord + vec2( -sx4,  0.0)).a;\n    sum += CCSampleWithAlphaSeparated(cc_spriteTexture, v_texcoord + vec2( -sx3, -sy1)).a;\n    sum += CCSampleWithAlphaSeparated(cc_spriteTexture, v_texcoord + vec2( -sx2, -sy2)).a;\n    sum += CCSampleWithAlphaSeparated(cc_spriteTexture, v_texcoord + vec2( -sx1, -sy3)).a;\n    sum += CCSampleWithAlphaSeparated(cc_spriteTexture, v_texcoord + vec2(  0.0, -sy4)).a;\n    sum += CCSampleWithAlphaSeparated(cc_spriteTexture, v_texcoord + vec2( +sx1, -sy3)).a;\n    sum += CCSampleWithAlphaSeparated(cc_spriteTexture, v_texcoord + vec2( +sx2, -sy2)).a;\n    sum += CCSampleWithAlphaSeparated(cc_spriteTexture, v_texcoord + vec2( +sx3, -sy1)).a;\n    sum -= 1.0;\n    sum *= 0.5;\n    sum = clamp(sum, 0.0, 1.0);\n  mediump vec4 icon = CCSampleWithAlphaSeparated(cc_spriteTexture, v_texcoord);\n  mediump vec4 outline = vec4(outlineColor.rgb, sum * outlineColor.a);\n    float iconA = icon.a;\n  mediump vec4 result = vec4(mix(outline.rgb, icon.rgb, iconA), iconA + (1.0 - iconA) * outline.a);\n    if(outlineOnly > 0.5)\n    {\n        sum *= (1.0 - iconA);\n        result = vec4(outlineColor.rgb, outlineColor.a * sum);\n    }\n    zo = result * color;\n    return zo;\n}\n  vec4 frag () {\n    vec4 o = vec4(1, 1, 1, 1);\n    #if USE_TEXTURE\n      o *= CCSampleWithAlphaSeparated(cc_spriteTexture, uv0);\n      #if IS_GRAY\n        float gray  = 0.2126 * o.r + 0.7152 * o.g + 0.0722 * o.b;\n        o.r = o.g = o.b = gray;\n      #endif\n    #endif\n    o *= color;\n    if(GrayEnable > 0.5){o = ZKGray(uv0, o);}\n    if(RotateEnable > 0.5){o = ZKRotate(uv0, o);}\n    if(GradientEnable > 0.5){o = ZKGradient(uv0, o);}\n    if(RadiusMoveEnable > 0.5){o = ZKRadiusMove(uv0, o);}\n    if(RectFrameEnable > 0.5){o = ZKRectFrame(uv0, o);}\n    if(RingEnable > 0.5){o = ZKRing(uv0, o);}\n    if(UVMaskEnable > 0.5){o = ZKUVMask(uv0, o);}\n    if(UVOffsetEnable > 0.5){o = ZKUVOffset(uv0, o);}\n    if(WaveEnable > 0.5){o = ZKWave(uv0, o);}\n    if(HSLEnable > 0.5){o = ZKHSL(uv0, o);}\n    if(SplitEnable > 0.5){o = ZKSplit(uv0, o);}\n    if(OutlineEnable > 0.5){o = ZKOutline(uv0, o);}\n        if(SolidColorEnable > 0.5){o = ZKSolidColor(uv0, o);}\n    ALPHA_TEST(o);\n    return o;\n  }\nvoid main() { gl_FragColor = frag(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCLocal","defines":["USE_LOCAL"]}],"samplerTextures":[{"name":"cc_spriteTexture","defines":["USE_TEXTURE"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":56,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":48}},"defines":[{"name":"USE_LOCAL","type":"boolean"},{"name":"SAMPLE_FROM_RT","type":"boolean"},{"name":"USE_PIXEL_ALIGNMENT","type":"boolean"},{"name":"CC_USE_EMBEDDED_ALPHA","type":"boolean"},{"name":"USE_ALPHA_TEST","type":"boolean"},{"name":"USE_TEXTURE","type":"boolean"},{"name":"IS_GRAY","type":"boolean"}]}],[{"passes":[{"program":"../framework/projectLib/psLayerEffectLib/chunkDefine/shaderEffect|vs:vert|fs:frag","blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendDstAlpha":4}]},"rasterizerState":{"cullMode":0},"depthStencilState":{"depthTest":false,"depthWrite":false},"properties":{"alphaThreshold":{"type":13,"value":[0.5]},"GrayEnable":{"type":13,"value":[0]},"pureColor":{"type":16,"value":[1,1,1,1]},"SolidColorEnable":{"type":13,"value":[0]},"rotateAngle":{"type":13,"value":[0]},"rotateUpRatio":{"type":13,"value":[0]},"rotateDownRatio":{"type":13,"value":[0]},"RotateEnable":{"type":13,"value":[0]},"leftGradientRatio":{"type":13,"value":[0]},"rightGradientRatio":{"type":13,"value":[0]},"topGradientRatio":{"type":13,"value":[0]},"bottomGradientRatio":{"type":13,"value":[0]},"GradientEnable":{"type":13,"value":[0]},"curAngle":{"type":13,"value":[0]},"angles":{"type":13,"value":[0]},"RadiusMoveEnable":{"type":13,"value":[0]},"xLineWidth":{"type":13,"value":[0]},"yLineHeight":{"type":13,"value":[0]},"nodeSize":{"type":14,"value":[0,0]},"rectFrameBKColor":{"type":16,"value":[1,1,1,1]},"useBKColor":{"type":13,"value":[0]},"RectFrameEnable":{"type":13,"value":[0]},"ringWidth":{"type":13,"value":[0]},"RingEnable":{"type":13,"value":[0]},"widthRatio":{"type":13,"value":[0]},"curRatio":{"type":13,"value":[0]},"UVMaskEnable":{"type":13,"value":[0]},"xOffset":{"type":13,"value":[0]},"UVOffsetEnable":{"type":13,"value":[0]},"WaveA":{"type":13,"value":[0]},"WaveT":{"type":13,"value":[0]},"WaveLineWidth":{"type":13,"value":[0]},"WaveOffset":{"type":13,"value":[0]},"WaveSita":{"type":13,"value":[0]},"elapseTime":{"type":13,"value":[0]},"WaveEnable":{"type":13,"value":[0]},"H":{"type":13,"value":[0]},"S":{"type":13,"value":[0]},"L":{"type":13,"value":[0]},"HSLEnable":{"type":13,"value":[0]},"splitSolid":{"type":13,"value":[0]},"splitEmpty":{"type":13,"value":[0]},"splitOffset":{"type":13,"value":[0]},"SplitEnable":{"type":13,"value":[0]},"outlineColor":{"type":16,"value":[1,1,1,1]},"outlineWidth":{"type":13,"value":[0]},"outlineOnly":{"type":13,"value":[0]},"OutlineEnable":{"type":13,"value":[0]}}}]}]]],0,0,[],[],[]]]]
